module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "beginMultipartUpload": function() { return /* reexport */ beginMultipartUpload; },
  "completeUploadPart": function() { return /* reexport */ completeUploadPart; },
  "getUploadPart": function() { return /* reexport */ getUploadPart; },
  "request": function() { return /* reexport */ request; }
});

;// CONCATENATED MODULE: ./src/core/request.ts
/**
 * Request using XHR client
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

var request = _async(function (config, options) {
  var url = getUrl(config, options);
  return _await(sendRequest(config, options, url), function (response) {
    var responseBody = getResponseBody(response);
    var responseHeader = getResponseHeader(response, options.responseHeader);
    return {
      url: url,
      ok: response.status >= 200 && response.status < 300,
      status: response.status,
      statusText: response.statusText,
      body: responseHeader || responseBody
    };
  });
});

var sendRequest = _async(function (config, options, url) {
  var xhr = new XMLHttpRequest();
  xhr.open(options.method, url, true);
  xhr.withCredentials = config.WITH_CREDENTIALS;
  return _await(getHeaders(config, options), function (headers) {
    headers.forEach(function (value, key) {
      xhr.setRequestHeader(key, value);
    });
    return new Promise(function (resolve) {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          resolve(xhr);
        }
      };

      xhr.send(getRequestBody(options));
    });
  });
});

var getHeaders = _async(function (config, options) {
  return _await(resolve(options, config.USERNAME), function (username) {
    return _await(resolve(options, config.PASSWORD), function (password) {
      return _await(resolve(options, config.HEADERS), function (defaultHeaders) {
        var headers = new Headers(Object.assign(Object.assign({
          Accept: contentTypeJson
        }, defaultHeaders), options.headers));

        if (isStringWithValue(username) && isStringWithValue(password)) {
          var credentials = btoa("".concat(username, ":").concat(password));
          headers.append("Authorization", "Basic ".concat(credentials));
        }

        if (options.body) {
          headers.append(contentType, contentTypeJson);
        }

        return headers;
      });
    });
  });
});

var resolve = _async(function (options, resolver) {
  return typeof resolver === "function" ? resolver(options) : resolver;
});

var contentType = "Content-Type";
var contentTypeJson = "application/json";

function isDefined(value) {
  return value !== undefined && value !== null;
}

function isStringWithValue(value) {
  return typeof value === "string" && value !== "";
}

function getQueryString(params) {
  var qs = [];
  Object.keys(params).forEach(function (key) {
    var value = params[key];

    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach(function (value) {
          qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(String(value))));
        });
      } else {
        qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(String(value))));
      }
    }
  });

  if (qs.length > 0) {
    return "?".concat(qs.join("&"));
  }

  return "";
}

function getUrl(config, options) {
  var path = options.path.replace(/[:]/g, "_");
  var url = "".concat(config.BASE).concat(path);

  if (options.query) {
    return "".concat(url).concat(getQueryString(options.query));
  }

  return url;
}

function getRequestBody(options) {
  if (options.body) {
    return JSON.stringify(options.body);
  }

  return undefined;
}

function getResponseHeader(xhr, responseHeader) {
  if (responseHeader) {
    return xhr.getResponseHeader(responseHeader);
  }

  return null;
}

function getResponseBody(xhr) {
  var headerValue = xhr.getResponseHeader(contentType);

  if (headerValue) {
    var isJSON = headerValue.toLowerCase().startsWith(contentTypeJson);

    if (isJSON) {
      return JSON.parse(xhr.responseText);
    } else {
      return xhr.responseText;
    }
  }

  return null;
}
;// CONCATENATED MODULE: ./src/services/UploadsService.ts


function UploadsService_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}
/**
 * Finalizes an upload part for an in-progress multipart upload. Required API key type: 'secret_*' or 'public_*'.
 * @param accountId
 * @param uploadId
 * @param uploadPartIndex
 * @param requestBody
 * @returns void
 * @throws ApiError
 */


function UploadsService_async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

/**
 * Gets a remaining upload part for an in-progress upload. Required API key type: 'secret_*' or 'public_*'.
 * @param accountId
 * @param uploadId
 * @param uploadPartIndex
 * @returns UploadPartV2 Success.
 * @throws ApiError
 */
var getUploadPart = UploadsService_async(function (config, accountId, uploadId, uploadPartIndex) {
  return request(config, {
    method: "GET",
    path: "".concat(accounts).concat(accountId).concat(uploads, "/").concat(uploadId).concat(parts).concat(uploadPartIndex)
  });
});
var completeUploadPart = UploadsService_async(function (config, accountId, uploadId, uploadPartIndex, requestBody) {
  return request(config, {
    method: "PUT",
    path: "".concat(accounts).concat(accountId).concat(uploads, "/").concat(uploadId).concat(parts).concat(uploadPartIndex),
    body: requestBody
  });
});
var beginMultipartUpload = UploadsService_async(function (config, accountId, requestBody) {
  return request(config, {
    method: "POST",
    path: "".concat(accounts).concat(accountId).concat(uploads),
    body: requestBody
  });
});
var accounts = "/v2/accounts/";
var uploads = "/uploads";
var parts = "/parts/";
;// CONCATENATED MODULE: ./src/index.ts
/* istanbul ignore file */

/* tslint:disable */

/* eslint-disable */




 // Used by upload-js

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.ts");
/******/ })()
;